# Описание
Цели данного задания:
* Практика использования библиотек для работы с http: `labstack/echo` и `go-resty/resty`
* Проектирование и использование NoSQL key/value хранилища с использованием `boltdb/bolt`
* Создание CLI приложения с использованием `spf13/cobra`
* Использование Unix Domain Socket как альтернативы TCP в качестве транспорта для http коммуникации в рамках одной машины

Приложение будет состоять из 2ух частей:
* `server` - http сервер, который будет обрабатывать приходящие запросы и хранить данные в `boltdb/bolt`
* `cli` - cli приложение, написанное с использованием `spf13/cobra`, которое будет отправлять запросы на сервер используя `go-resty/resty`

Коммуникация между клиентом и сервером будет осуществляться с помощью Unix Domain Socket

## Проектирование хранения данных
Для хранения информации мы будем использовать встраиваемую NoSQL базу данных `boltdb/bolt`.
Наше приложение должно хранить информацию о пользователях и их ролях и предоставлять следующие операции:
* Получение списка пользователей (всех, по роли или по email)
* Добавление пользователя
* Модификацию пользователя
* Удаление пользователя

Для хранения данных мы будем использовать 2 bucket'а:
* `users` - хранит информацию о пользователях. Ключом будет являться email пользователя, а значением - структура `User`
* `roles` - хранит информацию о ролях во вложенных бакетах для каждой роли. Ключом будет название роли, а значением - бакет с email'ами пользователей, которые имеют данную роль

Для того чтобы менять роли пользователям следует использовать тип `Set` и его методы `Difference` и `Equals`

## Тест
Тестирование приложения будет осуществляться с помощью `cli` приложения.
Это все на вас. Придумайте какие-нибудь тесты, меняйте юзеров и их роли, проверяйте доступность пользователей, через различные get запросы

# Продложение к заданию #1
Для того чтобы познакомиться с генерацией Swagger спецификации и использованием Swagger UI, мы добавим в приложение такую возможность.

## Что нужно сделать
1) Добавить 2 флага: -addr и -listener-type
    * -addr - адрес, который будет использоваться при создании листенера
    * -listener-type - тип листенера, который будет использоваться при создании листенера (tcp или unix)
    * Без использования флагов приложение не должно изменить свое поведение
2) Написать аннотации к методам, которые будут использоваться для генерации Swagger спецификации
    * Описывайте все методы в `handler.go`. Описание состоит из шапки и из коментариев которые относятся к каждому хендлеру в отдельности
    * Ссылка на формат: https://github.com/swaggo/swag#declarative-comments-format
3) Установить swag: `go install github.com/swaggo/swag/cmd/swag@latest`
4) В директории `server` сгенерировать документацию: `swag init --parseDependency`
5) Заимпортировать в main сегенерированную документацию `import _ "github.com/cloudmachinery/apps/http-userroles/server/docs"`
6) Добавить эндпоинт для получения документации: `e.GET("/swagger/*", echoSwagger.WrapHandler)` (для этого нужно установить `echoSwagger` пакет: `go get -u github.com/swaggo/echo-swagger`)
7) Запустить приложение на tcp листенере, открыть его в браузере по адресу `http://localhost:8080/swagger/index.html` (порт может отличаться) и проверить что документация отображается корректно

## Примеры аннотаций:
* Router - путь до эндпоинта и его метод: `// @Router /api/users/{email} [delete]`
* Param - параметр эндпоинта:
  * Если параметр пути: `// @Param email path string true "User email"`
  * Если параметр body: `// @Param user body contracts.User true "User"`
* Success - какой ответ ждать при успешном выполнении `// @Success 200 {array} contracts.User`
* Failure - какой ответ ждать при ошибке `// @Failure 400 {object} echo.HTTPError`
  * Укажите по аннотации для каждого кода ошибки

## Итоговая страница Swagger документации
![Swagger](./assets/swagger_example.png)

## Тест
1) Запустите сервер
2) Откройте в браузере страницу документации
3) Проверьте что все эндпоинты описаны корректно
4) Вызовите каждый эндпоинт и проверьте что ответы соответствуют описанию