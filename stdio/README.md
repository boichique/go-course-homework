# Описание
Для практики использования стандартных потоков ввода-вывода мы напишем 2 простые программы. Одна (`source`) будет генерировать случайные метрики и писать их в `stdout`, а другая (`collector`) будет читать их из `stdin`, считать диапазон метрик и писать в `stdout` изменения этого диапазона.

# `source`
## Описание
Программа должна генерировать случайные метрики и писать их в `stdout` в виде `metric: value`, например `metric: 32`. Продолжительность и частота генерации должны быть настраиваемыми. Также настраивается диапазон для случайной генерации `[from, to)`, по умолчанию `[0, 100)`. Для воспроизводимости резульатата нужно предоставить установку seed для генератора случайных чисел.

## Конфигурация
Для того чтобы сконфигурировать команду нужно использовать флаги:
```
-i: как часто должна генерироваться новая метрика (если не установлено: 100 миллисекунд)
-d: как долго должна длиться генерация (если не установлено: 10 секунд)
-f: начала диапазона метрик, включительно (если не установлено: 0)
-t: конец диапазона метрик, не включительно (если не установлено: 100)
```
и переменную окружения `RAND_SEED`. Если переменная окружения не установлена, то использовать текущее время в наносекундах в качестве seed.

## Полезные материалы
* Для установки флагов `-i` и `-d` используйте функцию `flag.DurationVar`, а для всех остальных `flag.IntVar`.
* Для выражения промежутка времени используйте выражения вида `time.Second*10`, `time.Millisecond*100` и т.д.
* Для работы со временем используйте функции
  * `time.Now()` - получить текущее время в виде `time.Time`
  * `time.Now().Nanosecond()` - получить текущее время в виде `int` в наносекундах
  * `time.Since(from)` - получить промежуток времени между `from` и текущим моментом
  * `time.Sleep(duration)` - заснуть на `duration`
* Для генерации случайных чисел используйте функции
  * `rand.New(source)` - создать генератор случайных чисел с источником `source`
  * `rand.New(rand.NewSource(seed))` - создать генератор случайных чисел с источником `rand.NewSource(seed)`
* Для получения значения переменной окружения используйте функцию `os.LookupEnv`
  * Если переменная окружения не установлена, то `os.LookupEnv` вернет `false` в качестве второго значения
  * Если значение переменной окружения не конвертируется в int - верните ошибку


## Тест
Чтобы проверить что все работает правильно, нужно запустить `make run-source` в директории `stdio` и получить следующий ответ:

```
metric: 738
metric: -322
metric: -801
metric: -749
metric: -84
metric: 548
metric: -106
metric: -679
metric: 783
metric: 349
metric: -510
metric: -134
metric: -457
metric: -641
metric: 28
metric: 50
metric: -337
metric: 514
metric: -401
metric: 32
metric: -868
metric: 635
metric: -248
metric: 338
metric: 921
```

# `collector`
## Описание
Программа должна получать метрики из `stdin` в виде `metric: value` и выводить в `stdout` изменения диапазона метрик, а по завернению писать финальное значение диапазона, кол-во полученных метрик и среднее значение (2 знака после точки). Смотри в секцию Test для большей информации

## Полезные материалы
* Для того чтобы выполнять построчное чтение из `os.Stdin` создайте `bufio.Scanner` и используйте его методы `Scan`, `Text` и `Err` для чтения строк. Для большей информации посмотрите примеры в [документации](https://go.dev/src/bufio/example_test.go). Особенно `ExampleScanner_lines`
* Для сканирования строки вида `metric: value` в значения используйте функцию `fmt.Sscanf`. Это функция антипод `fmt.Sprintf`. Она принимает строку и шаблон, а возвращает значения, которые были прочитаны из строки. Не забудьте использовать указатели на функции, чтобы `Sscanf` мог записать значения в переменные
* Для того чтобы писать в `stdout` используйте функцию `fmt.FPrintf(os.Stdout, ...)` вместо `fmt.Printf(...)` в рамках этой задачи
* Для того чтобы вывести число с 2 знаками после точки используйте функцию `fmt.Sprintf("%.2f", number)`. `.2` означает что нужно вывести 2 знака после точки, а `f` означает что это число с плавающей точкой

## Хитрости
* Для того чтобы легко работать с min и max - установите их в значения `math.MaxInt` и `math.MinInt` соответственно. Используйте эти значения как маркер того, что они не были установлены
Для этого может быть полезно использовать константы:
```go
const (
	noMin = math.MaxInt
	noMax = math.MinInt
)
min, max := noMin, noMax

// if min == noMin && max == noMax {} // min and max are not set
```

## Тест
Чтобы проверить что все работает правильно, нужно запустить `make run` в директории `stdio` и получить следующий ответ:

```
New range: [738:738]
New range: [-322:738]
New range: [-801:738]
New range: [-801:783]
New range: [-868:783]
New range: [-868:921]
Stats: metrics collected: 25 in range [-868: 921] with avg: -56.04
```