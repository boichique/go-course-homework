# Описание
Для практики использования интерфейсов и лучшего понимания как они нам могут упростить тестирование приложений мы напишем программу, которая рекурсивно находит все файлы в указанной папке и выводит для них sha256 хэши.

Для большего понимания как должен выглядеть вывод программы можно посмотреть файл `main_test.go`

## Конфигурация
Программа запускается в таком виде `filehashes [PATH]`, что значит, что она имеет всего один опциональный аргумент - пусть к папке, в которой нужно искать файлы. Если аргумент не указан, то программа должна искать файлы в текущей рабочей директории.

## Полезные материалы
* Работа с файловой системой:
  * Для получения доступа к аргументам командной строки можно получить через `os.Args[1:]`
  * Для получения текущей рабочей директории можно использовать `os.Getwd()`
  * Для проверки существования файла или папки можно использовать `_, err := os.Stat(path); err != nil`
  * Для рекурсивного обхода директории нужно использовать `fs.WalkDir(f, path, walkFunc)`, где последним аргументом мы должны предоставить функцию, которая будет вызвана для каждого файла или директории внутри `path`
  * Для определения является ли текущий объект файловой системы файлом или директорией можно использовать метод `IsDir()` определенный на интерфейсе `fs.DirEntry` (аргумент `walkFunc`)
  * Для того чтобы открыть файл (для чтения его содержимого) нужно использовать `Open()` определенный на интерфейсе `fs.FS`
* Рассчет хэша
  * Для того чтобы рассчитать хэш нужно использовать пакет `crypto/sha256` и создать объект типа `hash.Hash` с помощью функции `sha256.New()`
  * Для того чтобы посчитать хэш-сумму для бинарных данных (содержимое файла) можно использовать метод `Write()` у объекта типа `hash.Hash`, но так как файл является `io.Reader`, а `hash.Hash` является `io.Writer`, то можно использовать функцию `io.Copy()` для копирования содержимого файла в объект типа `hash.Hash`. Для финального получения хэш-суммы нужно использовать метод `Sum(nil)` у объекта типа `hash.Hash`. Больше примеров [здесь](https://gobyexample.com/sha256-hashes)
  * Для того чтобы получить строковое представление хэш-суммы в шестнадцатеричном виде можно использовать функцию `hex.EncodeToString()` 
* Для того чтобы писать в `io.Writer` нужно использовать `fmt.Fprintf(w, format, a...)`
* Для того чтобы сделать вывод в `os.Stdout` буфферизированным нужно использовать `bufio.NewWriter(os.Stdout)`.
  * Не забудьте вызвать метод `Flush()` у объекта типа `bufio.Writer` для того чтобы вывести все данные в `os.Stdout`. Сделать это нужно с помощью `defer w.Flush()` после создания объекта типа `bufio.Writer`

## Тест
Для тестирования программы нужно запустить `make test` в директории с заданием. Тест должен проходить успешно.

## Заметки
* Заметьте как хорошо интерфейсы работают друг с другом.
    * `hash.Hash` это `io.Writer`, `os.File` это `io.Reader` и они легко сочетаются друг с другом с помощью функции `io.Copy()`
    * Стандартный поток вывода в Go (`os.Stdout`) является `io.Writer` и мы можем подменить его на другую реализацию этого интерфейса для тестов `bytes.Buffer` (см. `main_test.go`)
* `fs.FS` является отличной иллюстрацией того, как интерфейсы могут быть полезны для тестирования. Вместо того чтобы использовать `os.Open()` для открытия файла (которая напрямую работает с файловой системой посредством системных вызовов операционной системы), мы можем использовать `fs.FS.Open()`. Это позволяет нам для работы реальной программы использовать настоящую файловую систему (`os.DirFS()`), а для тестов заменить ее на `fstest.MapFS`, что является просто типом `map[string]*MapFile` с набором методов для реализации интерфейса `fs.FS` (см. `main_test.go`). Так мы можем легко создавать файловые системы для тестов, которые не требуют настоящих файлов и директорий.