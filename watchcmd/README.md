# Описание
Для практики использования каналов и контекста мы напишем утилиту, которая будет работать схожим образом как и встроенная Linux утилита `watch`. Эта утилита запускает некоторую указанную команду с заданным интервалом времени и выводит её результат на экран.
Она может быть полезна, если вы ждете какого-то конкретного результата и чтобы не повторять ввод команды вручную вы можете использовать `watch`.
Напимер вы хотите узнать когда изменится статус какого-то сервиса и не хотите каждый раз вводить `systemctl status <service_name>`, вы можете просто запустить `watch systemctl status <service_name>`.
Для того чтобы понять как она работает запустите `watch date` и посмотрите как каждые 2 секунды выводится текущее время в консоль.

## Конфигурация
Конфигурация уже реализована. Она позволяет выбрать команду и интервал между запусками в следующем виде `watch -interval duration command args`, например `watch -interval 1s ls -1 .`.

## Задача
Модифицировать программу так, чтобыЖ
1) она выполняла команду по таймеру
2) могла реагировать на сигналы `SIGINT` и `SIGTERM` и завершать работу после того как текущий запуск команды завершится.
Но перед завершением команда должна писать в консоль `\nexiting...`
При получении сигнала мы должны отменять контекст, который передается в функцию `repeat`
Для реакции отмену контекста можно использовать либо цикл, либо `select`

- Обратите особое внимание на получение всех нераспаршенных аргументов через flag.Args()
- Обратите внимание на то как можно запустить дочерний процесс через `exec.Command()` и `exec.Cmd.Output()`
- Сигналы (например SIGINT) можно отправить процессу через `kill -s SIGINT <pid>`, где `<pid>` - это идентификатор процесса, который можно узнать через `pgrep watch`. Также это можно сделать из консоли: в Linux это Ctrl+C, в MacOS это Ctrl+.

## Тест
- Запустите программу через `make run` - она должна раз в секунду выдавать текущее время.
- Запустите команду `make kill` - она должна завершить работу программы `watch`.
- В консоли в которой была запущена программа должно появиться сообщение `exiting...` и программа должна завершиться.

## Полезные материалы:
- [сигналы](https://medium.com/nuances-of-programming/%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D0%BE%D0%B2-%D0%B2-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%D1%85-%D1%81%D0%B5%D0%BC%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B0-unix-%D0%BD%D0%B0-golang-cb2c42b80ba5) - подпишитесь на сигналы `SIGINT` и `SIGTERM`. При получении сигнала отмените контекст (в отдельной горутине вызовите `cancel()`)
- [time.Ticker](https://golang-blog.blogspot.com/2020/07/package-time-in-golang-ticker.html) - используйте для повторения команды с заданным интервалом. После создания тикера используйте канал `ticker.C` для получения событий запуска команды

